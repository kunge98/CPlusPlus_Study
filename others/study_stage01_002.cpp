#include <iostream>
#include <string>
using namespace std;

// 冒泡排序
// 数组的首地址，数组的长度
void bubble_sort(int *arr, int length){
    for (int i = 0; i < length-1; i++)
    {
        for (int j = 0; j < length-i-1; j++)
        {
            if (arr[j] > arr[j+1])
            {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

// 打印数组
void print_arr(int *arr, int length){
    for (int i = 0; i < length; i++)
    {
        cout << arr[i] << endl;
    }
}

int main(){

    /*
    24.指针（梦开始的地方）
    通过指针访问内存地址,指针就是一个地址
    定义指针：数据类型  *指针变量
    使用指针：通过解引用的方式来找到指针指向的内存，指针前加一个*,拿到具体的值
    指针也是数据类型，但是无论是什么数据类型，占据空间大小只依据操作系统
    32位占4字节，64位占8字节
    空指针：指针变量指向内存中编号为0的空间,初始化，但不可访问
    野指针：指针变量指正非法的内存空间，尽量避免出现野指针
    空指针和野指针都不是自己申请的空间，所以尽量不要访问
    */
    // int a = 10;
    // // 定义指针
    // int *p;
    // // 建立指针p与a的关系
    // p = &a;
    // // 发现两者指针指向的内存是一样的
    // cout << &a << "\n" << p << "\n" << endl;
    // // 解引用， *p直接会拿到具体的数值
    // cout << "解引用的指针拿到具体的数值" << *p << endl;
    // // 占据空间大小，都是8，都是在win64下
    // cout << "指针占据空间大小" <<sizeof(int *) << endl;
    // cout << "指针占据空间大小" <<sizeof(float *) << endl;
    // cout << "指针占据空间大小" <<sizeof(double *) << endl;
    // cout << "指针占据空间大小" <<sizeof(char *) << endl;
    // // 空指针，用于给指针变量初始化，空指针不可以进行访问的
    // int *p = NULL;
    // // 调用会报错，因为是空指针
    // // *p = 100;


    // const修饰指针三种情况：
    // 1.const修饰指针---常量指针
    // int a = 10;
    // int b = 10;
    // // 现在指针p解引用之后直接拿到了10，前面加入const代表常量指针
    // // 指针的指向是可以修改的，但是指针指向的数值不可以修改
    // const int *p = &a;
    // // *p = 20; 附带*代表可以直接拿到数值，这是不可以的
    // // p = &b;  改变了指针p的指向，是可以的


    //2.const修饰常量---指针常量
    // int a = 10;
    // int b = 10;
    // // 和1相反
    // // 指针常量中指针的指向不可以修改，指针指向的数值是可以进行修改的
    // int * const p = &a;
    // // *p = 20;可以进行修改
    // // p = &a; 不可以重新指向


    // 3.const既修饰常量，又修饰指针
    // int a = 10;
    // int b = 10;
    // const int * const p = &a;
    // // 指针的指向和指针指向的数值都不可以进行修改
    // // 以下两行代码都错误
    // // *p = 20；
    // // p = &b;

    /*
    常量指针和指针常量记忆方法：
    常量指针和指针常量通过英文的const和指针的*来记忆，const只对它后面的东西起作用

    const（常量）在前，*（指针）在后，就是常量指针，
    形式为 const int *p = &a,可以理解const修饰了*p，
    *p是可以直接拿到具体的数值的，所以但凡*p的操作都是不可以的

    *（指针）在前，const（常量）在后，就是指针常量，
    形式为 int * const p = &a,可以理解为const修饰了p，
    p是地址，可以指向内存地址，所以但凡和p的操作都是不可以的
    */


    // 指针和数组
    // int arr [10] = {1,2,3,4,5,6,7,8,9};
    // // 定义指针指向数组首地址
    // int *p = arr;
    // cout << *p << endl;
    // // 如果想访问第二个元素,*p表示解引用了，直接可以拿到数值，指针直接后移就可以
    // p++;
    // cout << *p << endl;
    // // 利用指针访问数组
    // for (int i = 0; i < 10; i++)
    // {
    //     cout << *p << endl;
    //     p++;
    // }


    // 指针和函数
    // 1.值传递，值传递是不会修改原本的参数的
    // swap(a, b);
    // 2.地址传递,传入的内存地址，可以修改原本的参数数值
    // swap(&a, &b);


    // 基础篇小案例
    // 封装一个函数，利用冒泡排序，实现对整形数组的升序排序

    int arr [10] = {4,3,6,9,1,2,10,8,7,5};

    // 传入数组的长度
    int length = sizeof(arr) / sizeof(arr[0]);
    bubble_sort(arr, length);
    print_arr(arr, length);


    system("pause");

}
